

符号表主要涉及的内容
	class 符号表
	1. 在符号表中创建记录，enter（name，type，offset）
	2. 生成三地址指令的方法，gen（code）
	3. 查询符号表，lookup（name）
	4. 关于变量在内存中的存储地址，可以考虑简单实现（在enter（，，）中填充）
	5. 关于newlabel和label的问题
		因为要用到临时变量，而且这个临时变量还会传过来传过去，直接实现不好使，所以打算用回填的方法来代替
		比如，如下部分
			if{B.true = newlabel（）；B.false = newlabel（）}B{。。。}
			then{label（B.true）；}S1{。。。}
			else{label（B.false）；}S2{。。。}
		可以替换为
			if{B.true = makeList（nextCode++）；B.false = makeList（nextCode++）}B{。。。}
			then{backpatch（B.true，nextCode++）；}S1{。。。}
			else{backpatch（B.false，nextCode++）；}S2{。。。}
		另外，如果出现了
			{B.begin = newlabel（）；}{C.next = B.begin}
		的情况，也可以替换为
			{B.begin = makeList（nextCode++）；}{C.next = B.begin}
		因为这样直接传递的时候只是传递引用，所以C.next和B.begin实际上指向内存中的同一个List
		如果之后出现了
			{label（B.next）}
		直接替换为
			{backpatch（B.next，nextCode++）}即可
		


用的时候可以考虑在语法分析的过程中，或者说语法分析过程中执行语义符号的代码的时候，
将整个class 符号表作为参数传递到语义符号的执行函数中，在其内部调用符号表的方法
（为了避免出现内存中有多个符号表，结果调用错误的情况，打算用单例模式实现）


关于回填的实现
	makeList（nextcode）——因为要回填，所以要把跳转目标的位置空出来
	merge（list1，list2）——简单的merge（并集）
	backpatch（list，nextcode）——
		考虑通过利用nextcode重新生成list对应的跳转指令的方法来实现
		不过这样的话，list就不能是单纯的java的List类，需要加上这个list对应的指令标号
		另外，gen（code）的方法也不能是简单的在string上添加内容，需要设置成一个List，存储一系列指令


关于过程调用的实现
	照着ppt来


错误检测
	最后再添上（到时候用exception来实现）